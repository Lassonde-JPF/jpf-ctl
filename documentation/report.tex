\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{times}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{automata}
\usepackage{tikz-uml}

\usepackage{amssymb}
\newcommand{\always}{\Box}
\newcommand{\eventually}{\Diamond}
\newcommand{\nxt}{\bigcirc}
\newcommand{\until}{\mathbin{\sf U}}

\newcommand{\TRUE}{\mbox{\lstinline{true}}}
\newcommand{\FALSE}{\mbox{\lstinline{false}}}
\newcommand{\NOT}{\mbox{\lstinline{!}}}
\newcommand{\AND}{\mathbin{\mbox{\lstinline{\&\&}}}}
\newcommand{\OR}{\mathbin{\mbox{\lstinline{||}}}}
\newcommand{\IMPLIES}{\mathbin{\mbox{\lstinline{->}}}}
\newcommand{\IFF}{\mathbin{\mbox{\lstinline{<->}}}}
\newcommand{\AX}{\mbox{\lstinline{AX}\,}}
\newcommand{\EX}{\mbox{\lstinline{EX}\,}}
\newcommand{\AG}{\mbox{\lstinline{AG}\,}}
\newcommand{\EG}{\mbox{\lstinline{EG}\,}}
\newcommand{\AF}{\mbox{\lstinline{AF}\,}}
\newcommand{\EF}{\mbox{\lstinline{EF}\,}}
\newcommand{\AU}{\mathbin{\mbox{\lstinline{AU}}}}
\newcommand{\EU}{\mathbin{\mbox{\lstinline{EU}}}}

\lstset{basicstyle=\ttfamily,mathescape=true}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newcommand{\comment}[1]{\hspace{2em}[\mbox{#1}]}

\usepackage{stmaryrd}
\newcommand{\satisfaction}[1]{\llbracket #1 \rrbracket}

\begin{document}

\title{}
\author{}
\date{\today}
\maketitle

\section{The Syntax of Computation Tree Logic}

\emph{Computation tree logic} (CTL) was introduced by Turing award winners Clarke and Emerson \cite{CE81}.  The formulas of this logic consist of the constants \lstinline{true} and \lstinline{false} and so-called atomic propositions which are combined by means of several operators that we will discuss below.  The \emph{atomic propositions} are used to express basic facts about the states of the system.  That is, these atomic propositions are state predicates.  In the next section, we provide some concrete examples of atomic propositions in the context of Java code.

CTL contains the operators
\begin{itemize}
\item
negation, denoted $\neg$,
\item 
conjunction, denoted by $\wedge$,
\item
disjunction, denoted $\vee$,
\item
implication, denoted $\rightarrow$, and
\item
equivalence, denoted $\leftrightarrow$.
\end{itemize}
Furthermore, it contains
\begin{itemize}
\item 
universal quantification, denoted $\forall$, and
\item
existential quantification, denoted $\exists$.
\end{itemize}
Finally, it contains the so-called temporal operators
\begin{itemize}
\item 
next, denoted $\nxt$,
\item
until, denoted $\until$,
\item
always, denoted $\always$, and
\item
eventually, denoted $\eventually$.
\end{itemize}

Let us formally define the syntax of CTL.  Let $\mathit{AP}$ be the set of atomic propositions.  The set of CTL formulas is defined by the following grammar.
\begin{align*}
\varphi
::= \, & ( \varphi ) 
\mid a\\
\mid\, & \TRUE
\mid \FALSE
\mid \neg \varphi
\mid \varphi \wedge \varphi
\mid \varphi \vee \varphi
\mid \varphi \rightarrow \varphi
\mid \varphi \leftrightarrow \varphi\\
\mid \, & \forall \nxt \varphi
\mid \exists \nxt \varphi
\mid \forall \varphi \until \varphi
\mid \exists \varphi \until \varphi
\mid \forall \always \varphi
\mid \exists \always \varphi
\mid \forall \eventually \varphi
\mid \exists \eventually \varphi
\end{align*}
where $a \in \mathit{AP}$.  

In order to make sense of a CTL formula such as
\[
\forall \nxt a \rightarrow b \rightarrow c
\]
we need to define the precedence of the operators.  Furthermore, we need to specify whether the binary operators are left or right associative.  For the order of precedence, we use the commonly accepted order (from highest to lowest): $\neg$, $\wedge$, $\vee$, $\rightarrow$, and $\leftrightarrow$.  According to Baier and Katoen \cite{BK08}, $\until$ takes precedence over $\wedge$, $\vee$, and $\rightarrow$ (they do not consider $\leftrightarrow$).  Usually, unary operators have higher precedence than binary ones.  Hence, the operators, listed from highest to lowest precedence, are
\begin{align*}
& \neg\\
& \forall \nxt, \exists \nxt, \forall \always, \exists \always, \forall \eventually, \exists \eventually\\
& \forall \until, \exists \until\\
& \wedge\\
& \vee\\
& \rightarrow\\
& \leftrightarrow
\end{align*}

The binary operators $\wedge$, $\vee$ and $\leftrightarrow$ are (left) associative.  Usually, $\rightarrow$ is considered right associative.  According to Baier and Katoen \cite{BK08}, $\until$ is also right associative.

Using the above specified precedence and associativity rules, the above CTL formula is interpreted as
\[
(\forall \nxt a) \rightarrow (b \rightarrow c)
\]

To express the CTL formulas in ASCII, we use the following grammar.
\begin{align*}
\varphi
::= \, & ( \varphi ) 
\mid a\\
\mid\, & \TRUE
\mid \FALSE
\mid \NOT \varphi
\mid \varphi \AND \varphi
\mid \varphi \OR \varphi
\mid \varphi \IMPLIES \varphi
\mid \varphi \IFF \varphi\\
\mid \, & \AX \varphi
\mid \EX \varphi
\mid  \varphi \AU \varphi
\mid \varphi \EU \varphi
\mid \AG \varphi
\mid \EG \varphi
\mid \AF \varphi
\mid \EF \varphi
\end{align*}
The ASCII representation of $\neg$, $\wedge$, and $\vee$ is taken from Java.  It is common practice to use \lstinline{A} and \lstinline{E} for universal (for \emph{a}ll) and existential (\emph{e}xists) quantification.  In the seminal paper by Turing award winner Pnueli \cite{P77}, the temporal operators $\nxt$, $\until$, $\always$, and $\eventually$ are represented as \lstinline{X} (ne\emph{x}t), \lstinline{U} (\emph{u}ntil), \lstinline{G} (\emph{g}lobally), and \lstinline{F} (\emph{f}uture).  The representation of $\forall \varphi \until \varphi$ as $\varphi \AU \varphi$ is new, as far as we know.  The above CTL formula is represented in ASCII as follows.
\begin{center}
\lstinline{AX a -> b -> c}
\end{center}

\section{The Syntax of Computation Tree Logic for Java}

The next operator $\nxt$ expresses that something holds in the next state.  For Java code, if one were to define the notion of next state, it would probably be the state after the next bytecode instruction has been executed.   However, expressing properties of Java code in terms to steps taken at the bytecode level seems of limited, if any, use.  Therefore, we do not consider the next operator $\nxt$.

Recall that atomic propositions are used to express basic facts about the states.  For now, we restrict our attention to static Boolean fields.  Such an atomic proposition holds in those states in which the field has the value true.  In Java, static Boolean fields are of the form 
\begin{itemize}
\item 
$\langle$package name$\rangle$ .\ $\langle$class name$\rangle$ .\ $\langle$field name$\rangle$ or
\item
$\langle$class name$\rangle$ .\ $\langle$field name$\rangle$.
\end{itemize}
For example, the package \lstinline{java.awt} contains the classes \lstinline{AWTEvent} and \lstinline{InvocationEvent}.  The former contains the static field \lstinline{consumed} and the latter contains \lstinline{catchExceptions}.  Hence, the static Boolean field \lstinline{java.awt.AWTEvent.consumed} is an atomic proposition, as is \lstinline{java.awt.InvocationEvent.catchExceptions}.  Those fields are used as atomic propositions in the following CTL formula.
\begin{lstlisting}
AG (java.awt.AWTEvent.consumed 
    || EF !java.awt.event.InvocationEvent.catchExceptions)
\end{lstlisting}

\section{A Lexer and Parser for CTL Formulas}

A lexer and parser for CTL formulas have been developed using ANTLR \cite{P13}.  The above described grammar can be specified in ANTLR format as folows.
\begin{lstlisting}
formula
  : '(' formula ')'			#Bracket
  | ATOMIC_PROPOSITION			#AtomicProposition
  | 'true'				#True
  | 'false'				#False
  | '!' formula				#Not
  | 'AG' formula			#ForAllAlways
  | 'AF' formula			#ForAllEventually
  | 'EG' formula			#ExistsAlways
  | 'EF' formula			#ExistsEventually
  | <assoc=right> formula 'AU' formula  #ForAllUntil
  | <assoc=right> formula 'EU' formula  #ExistsUntil
  | <assoc=left> formula '&&' formula	#And
  | <assoc=left> formula '| |' formula  #Or
  | <assoc=right> formula '->' formula  #Implies
  | <assoc=left> formula '<->' formula	#Iff
\end{lstlisting}
The operators \lstinline{AU}, \lstinline{EU}, and \lstinline{->} are specified as right associative.  The other binary operators are left associative.  The second column of the above rule contains the labels of the alternatives (see \cite[Section~8.2]{P13}).  We will discuss their role below.

The order of the alternatives is consistent with the precedence of the operators (if an operator has higher precedence, then its alternative occurs earlier).  \textcolor{red}{As a consequence, we had to order the operators \lstinline{AU} and \lstinline{EU}.  We gave \lstinline{AU} higher precedence than \lstinline{EU}.}
Assume that $a$, $b$, and $c$ are atomic propositions.  The formula \lstinline{$a$ AU $b$ AU $c$} is equivalent to \lstinline{$a$ AU ($b$ AU $c$)} since \lstinline{AU} is right associative.  The formula \lstinline{$a$ AU $b$ EU $c$} is equivalent to \lstinline{($a$ AU $b$) EU $c$} since \lstinline{AU} binds stronger than \lstinline{EU}.  For the same reason, the formula \lstinline{$a$ EU $b$ AU $c$} is equivalent to \lstinline{$a$ AU ($b$ EU $c$)}.

Recall that the atomic propositions are static attributes.  To specify these, we used relevant snippets of the ANTLR grammar for Java%
\footnote{See \href{https://github.com/antlr/grammars-v4/tree/master/java/java8}{github.com/antlr/grammars-v4/tree/master/java/java8}.}
Whitespace, that is, spaces, tabs, form feeds, and returns are skipped.

\textcolor{blue}{Later, we add here a discussion of error handling.}

\section{From Parse Tree to Abstract Syntax Tree}

Next, we translate a parse tree, generated by the lexer and parser, to an abstract syntax tree.  An abstract syntax tree for CTL is represented by an object of type \lstinline{Formula}, which is part of the package \lstinline{ctl}.  A UML diagram with the classes of the \lstinline{ctl} package can be found in Figure~\ref{figure:uml-abstract-syntax}.  The CTL formula
\begin{lstlisting}
AG (java.awt.AWTEvent.consumed 
    || EF !java.awt.event.InvocationEvent.catchExceptions)
\end{lstlisting}
is represented by the following \lstinline{Formula} object.
\begin{lstlisting}
Formula formula =
  new ForAllAlways(
    new Or(
      new AtomicProposition("java.awt.AWTEvent.consumed"),
      new ExistsEventually(
        new Not(
          new AtomicProposition("java.awt.event.InvocationEvent.catchExceptions")
        )
      )
    )
  );
\end{lstlisting}

\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}[xscale=1.5]
\begin{umlpackage}{ctl}
    
\umlsimpleclass[type=abstract, x = 0, y = 3.5]{Formula}{}{}

\umlsimpleclass[x = 5, y = 10]{AtomicProposition}{}{}
\umlsimpleclass[x = 5, y = 9]{True}{}{}
\umlsimpleclass[x = 5, y = 8]{False}{}{}
\umlsimpleclass[x = 5, y = 7]{Not}{}{}
\umlsimpleclass[x = 5, y = 6]{And}{}{}
\umlsimpleclass[x = 5, y = 5]{Or}{}{}
\umlsimpleclass[x = 5, y = 4]{Implies}{}{}
\umlsimpleclass[x = 5, y = 3]{Iff}{}{}
\umlsimpleclass[x = 5, y = 2]{ForAllAlways}{}{}
\umlsimpleclass[x = 5, y = 1]{ForAllEventually}{}{}
\umlsimpleclass[x = 5, y = 0]{ForAllUntil}{}{}
\umlsimpleclass[x = 5, y = -1]{ExistsAlways}{}{}
\umlsimpleclass[x = 5, y = -2]{ExistsEventually}{}{}
\umlsimpleclass[x = 5, y = -3]{ExistsUntil}{}{}

\umlinherit[geometry=-|-]{Formula}{AtomicProposition}
\umlinherit[geometry=-|-]{Formula}{True}
\umlinherit[geometry=-|-]{Formula}{False}
\umlinherit[geometry=-|-]{Formula}{Not}
\umlinherit[geometry=-|-]{Formula}{And}
\umlinherit[geometry=-|-]{Formula}{Or}
\umlinherit[geometry=-|-]{Formula}{Implies}
\umlinherit[geometry=-|-]{Formula}{Iff}
\umlinherit[geometry=-|-]{Formula}{ForAllAlways}
\umlinherit[geometry=-|-]{Formula}{ForAllEventually}
\umlinherit[geometry=-|-]{Formula}{ForAllUntil}
\umlinherit[geometry=-|-]{Formula}{ExistsAlways}
\umlinherit[geometry=-|-]{Formula}{ExistsEventually}
\umlinherit[geometry=-|-]{Formula}{ExistsUntil}

\umluniaggreg[geometry=-|, mult1=1, pos1=0.8, anchor1=160]{Not}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=160]{And}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=160]{Or}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=160]{Implies}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=-160]{Iff}{Formula}
\umluniaggreg[geometry=-|, mult1=1, pos1=0.8, anchor1=-160]{ForAllAlways}{Formula}
\umluniaggreg[geometry=-|, mult1=1, pos1=0.8, anchor1=-160]{ForAllEventually}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=-160]{ForAllUntil}{Formula}
\umluniaggreg[geometry=-|, mult1=1, pos1=0.8, anchor1=-160]{ExistsAlways}{Formula}
\umluniaggreg[geometry=-|, mult1=1, pos1=0.8, anchor1=-160]{ExistsEventually}{Formula}
\umluniaggreg[geometry=-|, mult1=2, pos1=0.8, anchor1=-160]{ExistsUntil}{Formula}   

\end{umlpackage}
\end{tikzpicture}
\end{center}
\caption{UML class diagram of the abstract syntax classes.}
\label{figure:uml-abstract-syntax}
\end{figure} 

To implement this translation, we use the visitor design pattern.  ANTLR supports this design pattern (see \cite[Section~7.3]{P13}).  From the CTL grammar, ANTLR generates a \lstinline{CTLVisitor} interface.  This interface contains a visit method for each alternative.  For example, for the alternative labelled \lstinline{ExistsAlways}, the interface contains the method \lstinline{visitExistsAlways}.

ANTLR also generates the \lstinline{CTLBaseVisitor} class.  This adapter class provides a default implementation for all the methods of the \lstinline{CTLVisitor} interface.  We implement our translation by extending this class and overriding methods.  For example, when we visit a node of the parse tree corresponding to the alternative labelled \lstinline{And}, we first visit the left child and obtain the \lstinline{Formula} object corresponding to the translation of the parse tree rooted at that left child.  Next, we visit the right child and obtain the \lstinline{Formula} object for the parse tree rooted at that right child.  Finally, we create an \lstinline{And} object from those two \lstinline{Formula} objects.

\begin{lstlisting}
@Override
public Formula visitAnd(AndContext context) {
  Formula left = (Formula) visit(context.formula(0));
  Formula right = (Formula) visit(context.formula(1));
  return new And(left, right);
}
\end{lstlisting}

Since the implication operator is right associative, in the \lstinline{visitImplies} method we visit the right child first.
\begin{lstlisting}
@Override
public Formula visitImplies(ImpliesContext context) {
  Formula right = (Formula) visit(context.formula(1));
  Formula left = (Formula) visit(context.formula(0));
  return new Implies(left, right);
}
\end{lstlisting}

\section{Testing the Lexer, the Parser, and the Translation}




\section{A New Semantics for CTL}

The normal semantics of CTL is described in \cite[Section~6.2.2]{BK08}.  This normal semantics is defined for a transition system $(S, Act, \rightarrow, I, AP, L)$.  Such a transition system is defined in \cite[Definition~2.1]{BK08}.  The new semantics considers a partial transition system.  A partial transition system is a tuple $(S, F, Act, \rightarrow, I, AP, L)$, where all components are defined as before and $F \subseteq S$ is a set of fully explored states.  A transition system is called partial because the states $S \setminus F$ are not fully explored yet, that is, these states \emph{have} transitions that are not part of the transition relation $\rightarrow$.  

Consider the following partial transition system.
\begin{center}
\begin{tikzpicture}[yscale=0.9]
\node (start) at (0,3) {};
\node[circle,fill=red!20] (-1) at (1,2.5) {-1};
\node[circle,fill=red!20] (0) at (1,1) {0};
\node[rectangle,fill=blue!20] (1) at (0,0) {1};
\node[rectangle,fill=red!20] (2) at (2,0) {2};

\draw[->] (start)--(-1);
\draw[->] (-1)--(0);
\draw[->] (0)--(1);
\draw[->] (0)--(2);
\end{tikzpicture}
\end{center}
State~-1 is the initial state.  The states -1 and 0 are fully explored, and  states 1 and 2 are not fully explored.  Consider, for example, the CTL formula $\exists \eventually\, \mbox{blue}$.  This formula holds in the above partial transition system, since state 1 is blue and can be reached from the initial state.  The CTL formula $\forall \always\, \mbox{red}$ does not hold for the same reason.  Now consider the CTL formula $\forall \always\, (\mbox{red} \vee \mbox{blue})$.  The above partial transition system does not provide a counterexample to this formula as all states that can be reached from the initial state are either red or blue.  However, since states 1 and 2 are not fully explored, either state may have a successor that is neither red nor blue.  So, the best we can say is ``don't know.''  Hence, whether a partial transition system satisfies a CTL formula can be answered as either yes ($\top$), no ($\perp$), or don't know (?).

Recall that the satisfaction relation $\models$, defined in \cite[Definition~6.4]{BK08}, can be viewed as mapping a state~$s$ of a transition system and a CTL formula~$\varphi$ to a Boolean, that is, $(s, \varphi)$ is mapped to true if $s \models \varphi$ and mapped to false otherwise.  The satisfaction relation $\models$ for CTL formulas on partial transition systems can be viewed as a mapping from states and formulas to $\top$, $\perp$, and ?.

We modify the definition of a transition system, as given in \cite[Definition~2.1]{BK08}, as follows.

\begin{definition}
A \emph{partial transition system} is a tuple $(S, F, \mathit{Act}, \rightarrow, I, \mathit{AP}, L)$ consisting of
\begin{itemize}
\item 
a set $S$ of \emph{states},
\item
a set $F \subseteq S$ of \emph{fully explored states},
\item
a set $\mathit{Act}$ of \emph{actions},
\item
a transition relation $\mathord{\rightarrow} \subseteq S \times \mathit{Act} \times S$,
\item
a set $I \subseteq S$ of \emph{initial states},
\item
a set $\mathit{AP}$ of \emph{atomic propositions}, and
\item
a \emph{labelling function} $L : S \to 2^{\mathit{AP}}$.
\end{itemize}
\end{definition}

The difference between a partial transition system and an ordinary transition system is the set $F$ of fully explored states.  Since the set $\mathit{Act}$ of actions does not play in the remainder, we will drop it from the definition and simplify the transition relation to $\mathord{\rightarrow} \subseteq S \times S$. The partial transition system depicted above can be formally defined as $(S, F, \rightarrow, I, \mathit{AP}, L)$ where
\begin{itemize}
\item 
$S = \{ -1, 0, 1, 2 \}$,
\item
$F = \{ -1, 0 \}$,
\item
$\mathord{\rightarrow} = \{ (-1, 0), (0, 1), (0, 2) \}$,
\item
$I = \{ -1 \}$,
\item
$\mathit{AP} = \{ \mbox{blue}, \mbox{red} \}$, and
\item
and the function $L : S \to 2^{\mathit{AP}}$ is defined by
\begin{align*}
L(-1) & = \{ \mbox{red} \}\\
L(0) & = \{ \mbox{red} \}\\
L(1) & = \{ \mbox{blue} \}\\
L(2) & = \{ \mbox{red} \}
\end{align*}
\end{itemize} 

\color{red}
Due to the presence of unexplored states, we also revisit the definition of paths.  We fix a set $\mathcal{S}$ and we assume that for each partial transition system we have that $S \subseteq \mathcal{S}$.  We denote the set of nonempty and finite sequences of states in $\mathcal{S}$ by $\mathcal{S}^*$, the set of infinite sequences of states in $\mathcal{S}$ by $\mathcal{S}^{\omega}$, and the set of nonempty finite and infinite sequences of states in $\mathcal{S}$ by $\mathcal{S}^{\infty}$.

\begin{definition}
Let $(S, F, \rightarrow, I, \mathit{AP}, L)$ be a partial transition system.
\begin{itemize}
\item 
The nonempty and finite sequence $s_0 s_1 \ldots s_n$ in $\mathcal{S}^*$, where $n \geq 0$, is a path if $s_i \rightarrow s_{i+1}$ for all $0 \leq i < n$ and $s_n \not\rightarrow$ and $s_n \in F$.
\item 
The infinite sequence $s_0 s_1 \ldots$ in $\mathcal{S}^{\omega}$ is a path if $s_i \rightarrow s_{i+1}$ for all $i \geq 0$. 
\end{itemize}
\end{definition}

Note that we require that the final state of a finite path is fully explored.

\begin{definition}
Let $(S, F, \rightarrow, I, \mathit{AP}, L)$ be a partial transition system.
\begin{itemize}
\item 
The nonempty and finite sequence $s_0 s_1 \ldots s_n s_{n+1} \ldots s_{n+m}$ in $\mathcal{S}^*$, where $n \geq 0$ and $m \geq 1$, is a potential path if $s_i \rightarrow s_{i+1}$ for all $0 \leq i < n$ and $s_n \not\in F$ and $s_n \not\rightarrow s_{n+1}$.
\item 
The infinite sequence $s_0 s_1 \ldots s_n s_{n+1} \ldots$ in $\mathcal{S}^{\omega}$, where $n \geq 0$, is a potential path if $s_i \rightarrow s_{i+1}$ for all $0 \leq i < n$ and $s_n \not\in F$ and $s_n \not\rightarrow s_{n+1}$.
\end{itemize}
\end{definition}

In the first case, the sequence $s_0 s_1 \ldots s_n s_{n+1} \ldots s_{n+m}$ consists of two parts: $s_0 s_1 \ldots s_n$ traverses the explored part of the partial transition system, whereas $s_{n+1} \ldots s_{n+m}$ traverses the unexplored part.  Note that we require that $s_n \not\rightarrow s_{n+1}$: otherwise $s_{n+1}$ would belong to the explored part.  Similarly, the sequence $s_0 s_1 \ldots s_n s_{n+1} \ldots$ consists of the parts $s_0 s_1 \ldots s_n$ and $s_{n+1} \ldots$.  

We denote the set of potential paths that start in state $s$ by $\mathit{PPaths}(s)$.  We denote the set of (actual) paths that start in state $s$ by $\mathit{APaths}(s)$.  We denote the set of all paths that start in state $s$ by $\mathit{Paths}(s)$.

Consider the following partial transition system.
\begin{center}
\begin{tikzpicture}[yscale=0.9]
\node (start) at (0,3) {};
\node[circle,fill=red!20] (-1) at (1,2.5) {-1};
\node[rectangle,fill=red!20] (0) at (1,1) {0};
\node[rectangle,fill=blue!20] (1) at (0,0) {1};
\node[circle,fill=red!20] (2) at (2,0) {2};

\draw[->] (start)--(-1);
\draw[->] (-1)--(0);
\draw[->] (0)--(1);
\draw[->] (0)--(2);
\end{tikzpicture}
\end{center}
We have that
\begin{align*}
\mathit{APaths}(-1) & = \{ -1\ 0\ 2 \}\\
\mathit{PPaths}(-1) & = \{\, -1\ 0\ \pi \mid \pi[0] \not\in \{ 1, 2 \} \wedge \pi \in S^{\infty} \,\} \cup \{\, -1\ 0\ 1\ \pi \mid \pi \in S^{\infty} \,\}
\end{align*}
Since state 0 is not fully explored yet, we know that this state has more outgoing transitions than the two depicted in the above diagram.  All the potential paths starting with $-1\ 0$ do not start with either $-1\ 0\ 1$ or $-1\ 0\ 2$.  Since state 1 is not fully explored, it is not a final state and, as a result, the sequence $-1\ 0\ 1$ is \emph{not} a potential path.

A partial transition system in which all states are fully explored, that is, an ordinary transition system, has no potential paths.

\begin{proposition}
\label{proposition:no-potential-paths}
If $F= S$ then $\mathit{PPAths}(s) = \emptyset$ for all $s \in S$.
\end{proposition}
\begin{proof}
Immediate from the definition of potential paths.
\end{proof}

\color{black}
The satisfaction relation $\models$ for CTL for ordinary transition systems is defined in \cite[Definition~6.4]{BK08}.  It can be viewed as a function $\satisfaction{\ }$ that maps each CTL formula and state of a transition system to either true of false, that is, for each state formula $\varphi$ and state $s$,
\[
s \models \varphi \mbox{ iff } \satisfaction{\varphi}(s) = \mbox{true}.
\]

To deal with partial transition systems, we extend the range of the function $\satisfaction{\ }$.  Given a formula $\varphi$ and a state $s$, we have that either
\begin{itemize}
\item 
$\satisfaction{\varphi}(s) = \top$: the formula $\varphi$ holds in the state $s$,
\item
$\satisfaction{\varphi}(s) = \perp$: the formula $\varphi$ does not hold in the state $s$, or
\item
$\satisfaction{\varphi}(s) = \mathord{?}$: we cannot determine whether the formula $\varphi$ holds in the state $s$ since some states, relevant to $\varphi$,  have not been explored.
\end{itemize}

For example, consider the partial transition system depicted above.  Consider the formula $\forall \nxt \mbox{red}$.  We have that $\satisfaction{\forall \nxt \mbox{red}}(-1) = \top$ since the state $-1$ is fully explored and all its successor states are red.  Furthermore, $\satisfaction{\forall \nxt \mbox{red}}(0) = \perp$ since one of the  successor states of state 0 is not red.  Finally, $\satisfaction{\forall \nxt \mbox{red}}(1) = \mathord{?}$ since the state 1 is not fully explored and it does not have a successor that is not red.

We denote the set of three values, $\top$, $\perp$ and $?$ by $\mathbb{V}$, that is,
\[
\mathbb{V} = \{ \top, \perp, \mathord{?} \}.
\]
We can extend the usual Boolean operators to $\mathbb{V}$ as follows.  Negation is captured in the following table.
\[
\begin{array}{c|c}
v & \neg v\\\hline
\top & \perp\\
\perp & \top\\
\mathord{?} & \mathord{?}
\end{array}
\]
Conjunction is defined as follows.
\[
\begin{array}{cc|ccc}
\multicolumn{2}{c|}{v \wedge w} & & w &\\
&& \top & \perp & \mathord{?}\\\hline
& \top & \top & \perp & \mathord{?}\\
v & \perp & \perp & \perp & \perp\\
& \mathord{?} & \mathord{?} & \perp & \mathord{?}
\end{array}
\]
Disjunction is defined as follows.
\[
\begin{array}{cc|ccc}
\multicolumn{2}{c|}{v \vee w} & & w &\\
&& \top & \perp & \mathord{?}\\\hline
& \top & \top & \top & \top\\
v & \perp & \top & \perp & \mathord{?}\\
& \mathord{?} & \top & \mathord{?} & \mathord{?}
\end{array}
\]
Implication is defined as follows.
\[
\begin{array}{cc|ccc}
\multicolumn{2}{c|}{v \rightarrow w} & & w &\\
&& \top & \perp & \mathord{?}\\\hline
& \top & \top & \perp & ?\\
v & \perp & \top & \top & \top\\
& \mathord{?} & \top & \perp & ?
\end{array}
\]
Equivalence is defined as follows.
\[
\begin{array}{cc|ccc}
\multicolumn{2}{c|}{v \leftrightarrow w} & & w &\\
&& \top & \perp & \mathord{?}\\\hline
& \top & \top & \perp & ?\\
v & \perp & \perp & \top & ?\\
& \mathord{?} & ? & \perp & ?
\end{array}
\]

\color{red}
We denote the length of a (potential) path $\pi$ by $|\pi|$.  If the (potential) path $\pi$ is infinite, then $|\pi| = \omega$.  We denote the set of CTL formulas by $\mathit{CTL}$.

\begin{definition}
Let $(S, F, \rightarrow, I, \mathit{AP}, L)$ be a partial transition system.  The function 
\[
\satisfaction{\ } : \mathit{CTL} \to S \to \mathbb{V}
\] 
is defined by structural induction on the CTL formula as follows.
\begin{itemize}
\item 
$\satisfaction{a}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $a \in L(s)$}\\
\perp & \mbox{otherwise}
\end{array}\right .
$
\item 
$\satisfaction{\TRUE}(s) = \top$ 
\item 
$\satisfaction{\FALSE}(s) = \perp$ 
\item 
$\satisfaction{\neg \varphi}(s) = \neg \satisfaction{\varphi}(s)$ 
\item 
$\satisfaction{\varphi \wedge \psi}(s) = \satisfaction{\varphi}(s) \wedge \satisfaction{\psi}(s)$ 
\item 
$\satisfaction{\varphi \vee \psi}(s) = \satisfaction{\varphi}(s) \vee \satisfaction{\psi}(s)$ 
\item 
$\satisfaction{\varphi \rightarrow \psi}(s) = \satisfaction{\varphi}(s) \rightarrow \satisfaction{\psi}(s)$ 
\item 
$\satisfaction{\varphi \leftrightarrow \psi}(s) = \satisfaction{\varphi}(s) \leftrightarrow \satisfaction{\psi}(s)$ 
\item
$\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[1]) = \top$ for all $\pi \in \mathit{Paths}(s)$ with $|\pi| > 1$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[1]) = \perp$ for some $\pi \in \mathit{APaths}(s)$ with $|\pi| > 1$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[1]) = \top$ for some $\pi \in \mathit{APaths}(s)$ with $|\pi| > 1$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[1]) = \perp$ for all $\pi \in \mathit{Paths}(s)$ with $|\pi| > 1$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \top$ for all $\pi \in \mathit{Paths}(s)$ and $0 \leq i < |\pi|$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \perp$ for some $\pi \in \mathit{APaths}(s)$ and $0 \leq i < |\pi|$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\exists \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \top$ for some $\pi \in \mathit{APaths}(s)$ and for all $0 \leq i < |\pi|$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \perp$ for all $\pi \in \mathit{Paths}(s)$ and for some $0 \leq i < |\pi|$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\forall \eventually \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \top$ for all $\pi \in \mathit{Paths}(s)$ and for some $0 \leq i < |\pi|$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \perp$ for some $\pi \in \mathit{APaths}(s)$ and for all $0 \leq i < |\pi|$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\exists \eventually \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \top$ for some $\pi \in \mathit{APaths}(s)$ and $0 \leq i < |\pi|$}\\
\perp & \mbox{if $\satisfaction{\varphi}(\pi[i]) = \perp$ for all $\pi \in \mathit{Paths}(s)$ and $0 \leq i < |\pi|$}\\
? & \mbox{otherwise}
\end{array}
\right .
$
\item
$\satisfaction{\forall \varphi \until \psi}(s) = $ \textcolor{blue}{details still need to be added here.}
\item
$\satisfaction{\exists \varphi \until \psi}(s) = $ \textcolor{blue}{details still need to be added here.}
\end{itemize}
\end{definition}

For a partial transition system in which all states are fully explored, that is, an ordinary transition system, $\satisfaction{\ }$ corresponds to $\models$ as defined in \cite[Definition~6.4]{BK08} adjusted to deal with finite paths as follows:
\begin{itemize}
\item 
$s \models \forall \nxt \varphi$ iff for all $\pi \in \mathit{APaths}(s)$ with $|\pi| > 1$, $\pi[1] \models \varphi$ 
\item
$s \models \exists \nxt \varphi$ iff for some $\pi \in \mathit{APaths}(s)$ with $|\pi| > 1$, $\pi[1] \models \varphi$
\item 
$s \models \forall \varphi \until \psi$ iff for all $\pi \in \mathit{APaths}(s)$, there exists $0 \leq j < |\pi|$ such that $\pi[j] \models \psi$ and for all $0 \leq k < j$, $\pi[j] \models \varphi$
\item
$s \models \exists \varphi \until \psi$ iff for some $\pi \in \mathit{APaths}(s)$, there exists $0 \leq j < |\pi|$ such that $\pi[j] \models \psi$ and for all $0 \leq k < j$, $\pi[j] \models \varphi$
\end{itemize}

\begin{proposition}
If $F = S$, for all $\varphi \in \mathit{CTL}$ and $s \in S$, 
\begin{itemize}
\item
$\satisfaction{\varphi}(s) = \top$ iff $s \models \varphi$, and
\item
$\satisfaction{\varphi}(s) = \perp$ iff $s \not\models \varphi$.
\end{itemize}
\end{proposition}
\begin{proof}
Let $s \in S$.  We prove this proposition by structural induction on $\varphi$.  We distinguish the following cases.
\begin{itemize}
\item 
For the CTL formula $a$ we have that
\[
\satisfaction{a}(s) = \top \mbox{ iff } a \in L(s) \mbox{ iff } s \models a
\]
and
\[
\satisfaction{a}(s) = \perp \mbox{ iff } a \not\in L(s) \mbox{ iff } s \not\models a.
\]
\item
For the CTL formula $\neg \varphi$ we have that
\begin{align*}
& \satisfaction{\neg \varphi}(s) = \top\\
\mbox{iff } & \satisfaction{\varphi}(s) = \perp\\
\mbox{iff } & s \not\models \varphi 
\comment{by induction}\\
\mbox{iff } & s \models \neg \varphi 
\end{align*}
and
\begin{align*}
& \satisfaction{\neg \varphi}(s) = \perp\\
\mbox{iff } & \satisfaction{\varphi}(s) = \top\\
\mbox{iff } & s \models \varphi 
\comment{by induction}\\
\mbox{iff } & s \not\models \neg \varphi 
\end{align*}
\item
For the CTL formula $\varphi \wedge \psi$ we have that
\begin{align*}
& \satisfaction{\varphi \wedge \psi}(s) = \top\\
\mbox{iff } & \satisfaction{\varphi}(s) = \top \mbox{ and } \satisfaction{\psi}(s) = \top\\
\mbox{iff } & s \models \varphi \mbox{ and }  s \models \psi
\comment{by induction}\\
\mbox{iff } & s \models \varphi \wedge \psi
\end{align*}
and
\begin{align*}
& \satisfaction{\varphi \wedge \psi}(s) = \perp\\
\mbox{iff } & \satisfaction{\varphi}(s) = \perp \mbox{ or } \satisfaction{\psi}(s) = \perp\\
\mbox{iff } & s \not\models \varphi \mbox{ or } s \not\models \psi
\comment{by induction}\\
\mbox{iff } & s \not\models \varphi \wedge \psi
\end{align*}
\item
For the CTL formula $\forall \nxt \varphi$ we have that
\begin{align*}
& \satisfaction{\forall \nxt \varphi}(s) = \top\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{Paths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \top\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \top
\comment{Proposition~\ref{proposition:no-potential-paths}}\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \pi[1] \models \varphi
\comment{by induction}\\
\mbox{iff } & s \models \forall \nxt \varphi
\end{align*}
and
\begin{align*}
& \satisfaction{\forall \nxt \varphi}(s) = \perp\\
\mbox{iff } & \mbox{for some } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \perp\\
\mbox{iff } & \mbox{for some } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \pi[1] \not\models \varphi
\comment{by induction}\\
\mbox{iff } & s \not\models \forall \nxt \varphi
\end{align*}
\item
For the CTL formula $\exists \nxt \varphi$ we have that
\begin{align*}
& \satisfaction{\exists \nxt \varphi}(s) = \top\\
\mbox{iff } & \mbox{for some } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \top\\
\mbox{iff } & \mbox{for some } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \pi[1] \models \varphi
\comment{by induction}\\
\mbox{iff } & s \models \exists \nxt \varphi
\end{align*}
and
\begin{align*}
& \satisfaction{\exists \nxt \varphi}(s) = \perp\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{Paths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \perp\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \satisfaction{\varphi}(\pi[1]) = \perp
\comment{Proposition~\ref{proposition:no-potential-paths}}\\
\mbox{iff } & \mbox{for all } \pi \in \mathit{APaths}(s) \mbox{ with } |\pi| > 1, \pi[1] \not\models \varphi
\comment{by induction}\\
\mbox{iff } & s \not\models \exists \nxt \varphi
\end{align*}
\item
For the CTL formula $\forall \varphi \until \psi$ we have that \textcolor{blue}{details still need to be added here.}
\item
For the CTL formula $\exists \varphi \until \psi$ we have that
\textcolor{blue}{details still need to be added here.}
\end{itemize}
\end{proof}

\color{black}
We use $2^S$ to denote the powerset of $S$.  For each CTL formula we define the following two sets of states.

\begin{definition}
Let $\varphi$ be a CTL formula.  Then
\begin{align*}
\mathit{Sat}(\varphi) & = \{\, s \in S \mid \satisfaction{\varphi}(s) = \top \,\}\\
\mathit{Unsat}(\varphi) & = \{\, s \in S \mid \satisfaction{\varphi}(s) = \perp \,\}
%\mathit{Unknown}(\varphi) & = \{\, s \in S \mid \satisfaction{\varphi}(s) = ? \,\}
\end{align*}
\end{definition}
\color{black}

\begin{theorem}
Let $(S, F, \rightarrow, I, \mathit{AP}, L)$ be a partial transition system.  For all $a \in \mathit{AP}$ and $\varphi$, $\psi \in \mathit{CTL}$,
\begin{itemize}
\item
\begin{align*}
\mathit{Sat}(a) & = \{\, s \in S \mid a \in L(s) \,\}\\
\mathit{Unsat}(a) & = \{\, s \in S \mid a \not\in L(s) \,\}
%\mathit{Unknown}(a) & = \emptyset
\end{align*}
\item 
\begin{align*}
\mathit{Sat}(\TRUE) & = S\\
\mathit{Unsat}(\TRUE) & = \emptyset
%\mathit{Unknown}(\TRUE) & = \emptyset
\end{align*}
\item 
\begin{align*}
\mathit{Sat}(\FALSE) & = \emptyset\\
\mathit{Unsat}(\FALSE) & = S\
%\mathit{Unknown}(\FALSE) & = \emptyset 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\neg \varphi) & = \mathit{Unsat}(\varphi)\\
\mathit{Unsat}(\neg \varphi) & = \mathit{Sat}(\varphi)
%\mathit{Unknown}(\neg \varphi) & = \mathit{Unknown}(\varphi)
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\varphi \wedge \psi) & = \mathit{Sat}(\varphi) \cap \mathit{Sat}(\psi)\\
\mathit{Unsat}(\varphi \wedge \psi) & = \mathit{Unsat}(\varphi) \cup \mathit{Unsat}(\psi)
%\mathit{Unknown}(\varphi \wedge \psi) & = S \setminus (\mathit{Sat}(\varphi \wedge \psi) \cup \mathit{Unsat}(\varphi \wedge \psi))
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\varphi \vee \psi) & = \mathit{Sat}(\varphi) \cup \mathit{Sat}(\psi)\\
\mathit{Unsat}(\varphi \vee \psi) & = \mathit{Unsat}(\varphi) \cap \mathit{Unsat}(\psi)
%\mathit{Unknown}(\varphi \vee \psi) & = S \setminus (\mathit{Sat}(\varphi \vee \psi) \cup \mathit{Unsat}(\varphi \vee \psi))
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\varphi \rightarrow \psi) & = \mathit{Unsat}(\varphi) \cup \mathit{Sat}(\psi)\\
\mathit{Unsat}(\varphi \rightarrow \psi) & = \mathit{Unsat}(\varphi) \setminus \mathit{Unsat}(\psi)
%\mathit{Unknown}(\varphi \rightarrow \psi) & = S \setminus (\mathit{Sat}(\varphi \rightarrow \psi) \cup \mathit{Unsat}(\varphi \rightarrow \psi))
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\varphi \leftrightarrow \psi) & = \\
\mathit{Unsat}(\varphi \leftrightarrow \psi) & = 
%\mathit{Unknown}(\varphi \leftrightarrow \psi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\forall \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S & \mbox{if $\varphi \equiv \TRUE$}\\
\{\, s \in F \mid \mathit{post}(s) \subseteq \mathit{Sat}(\varphi) \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unsat}(\forall \nxt \varphi) & = 
\left \{
\begin{array}{ll}
(S \setminus F) \cup \{\, s \in F \mid \mathit{post}(s) \not= \emptyset \,\}& \mbox{if $\varphi \equiv \FALSE$}\\
\{\, s \in S \mid \mathit{post}(s) \cap \mathit{Unsat}(\varphi) \not= \emptyset \,\} & \mbox{otherwise}
\end{array}
\right .
%\mathit{Unknown}(\forall \nxt \varphi) & = S \setminus (\mathit{Sat}(\forall \nxt \varphi) \cup \mathit{Unsat}(\forall \nxt \varphi))
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\exists \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S \setminus F \cup \{\, s \in F \mid \mathit{post}(s) \not= \emptyset \,\} & \mbox{if $\varphi \equiv \TRUE$}\\
\{\, s \in S \mid \mathit{post}(s) \cap \mathit{Sat}(\varphi) \not= \emptyset \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unsat}(\exists \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S & \mbox{if $\varphi \equiv \FALSE$}\\
\{\, s \in F \mid \mathit{post}(s) \subseteq \mathit{Unsat}(\varphi) \,\} & \mbox{otherwise}
\end{array}
\right .
%\mathit{Unknown}(\exists \nxt \varphi) & = S \setminus (\mathit{Sat}(\exists \nxt \varphi) \cup \mathit{Unsat}(\exists \nxt \varphi))
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\forall \varphi \until \psi) & = \\
\mathit{Unsat}(\forall \varphi \until \psi) & = 
%\mathit{Unknown}(\forall \varphi \until \psi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\exists \varphi \until \psi) & = \\
\mathit{Unsat}(\exists \varphi \until \psi) & = 
%\mathit{Unknown}(\exists \varphi \until \psi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\forall \always \varphi) & = \\
\mathit{Unsat}(\forall \always \varphi) & = 
%\mathit{Unknown}(\forall \always \varphi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\exists \always \varphi) & = \\
\mathit{Unsat}(\exists \always \varphi) & = 
%\mathit{Unknown}(\exists \always \varphi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\forall \eventually \varphi) & = \\
\mathit{Unsat}(\forall \eventually \varphi) & = 
%\mathit{Unknown}(\forall \eventually \varphi) & = 
\end{align*}
\item
\begin{align*}
\mathit{Sat}(\exists \eventually \varphi) & = \\
\mathit{Unsat}(\exists \eventually \varphi) & = 
%\mathit{Unknown}(\exists \eventually \varphi) & = 
\end{align*}
\end{itemize}
\end{theorem}
\color{red}
\begin{proof}
The first eight cases follow immediately from the definitions.  For example, for the case $\varphi \wedge \psi$ we have that
\begin{align*}
\mathit{Sat}(\varphi \wedge \psi) 
& = \{\, s \in S \mid \satisfaction{\varphi \wedge \psi}(s) = \top \,\}\\
& = \{\, s \in S \mid \satisfaction{\varphi}(s) = \top \mbox{ and } \satisfaction{\psi}(s) = \top \,\}\\
& = \{\, s \in S \mid \satisfaction{\varphi}(s) = \top \,\} \cap \{\, s \in S \mid \satisfaction{\psi}(s) = \top \,\}\\
& = \mathit{Sat}(\varphi) \cap \mathit{Sat}(\psi)
\end{align*}
and
\begin{align*}
\mathit{Unsat}(\varphi \wedge \psi) 
& = \{\, s \in S \mid \satisfaction{\varphi \wedge \psi}(s) = \perp \,\}\\
& = \{\, s \in S \mid \satisfaction{\varphi}(s) = \perp \mbox{ or } \satisfaction{\psi}(s) = \perp \,\}\\
& = \{\, s \in S \mid \satisfaction{\varphi}(s) = \perp \,\} \cup \{\, s \in S \mid \satisfaction{\psi}(s) = \perp \,\}\\
& = \mathit{Unsat}(\varphi) \cup \mathit{Unsat}(\psi)
\end{align*}
\begin{itemize}
\item 
\textcolor{blue}{The remaining cases still need to be done.}
\end{itemize}

\end{proof}
\color{black}

We first consider the formula $\forall \nxt \varphi$, where $\varphi$ is some arbitrary formula.  Assume that the state~$s$ is fully explored.  In that case,
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s') = \top$ for all $s \rightarrow s'$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s') = \perp$ for some $s \rightarrow s'$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
The above is equivalent to
\[
\satisfaction{\forall \nxt \varphi}(s) = \bigwedge \{\, \satisfaction{\varphi}(s') \mid s \rightarrow s' \,\}.
\]
Note that $\bigwedge \emptyset = \top$.

Next, assume that the state~$s$ is not fully explored.  Recall that state~$s$ has outgoing transitions, but those have not been explored yet.  We distinguish three cases.
\begin{itemize}
\item 
None of outgoing transitions of state~$s$ have been explored yet.  Let us first consider the case that $\varphi$ is $\TRUE$.  In that case, $\satisfaction{\forall \nxt \TRUE}(s) = \top$ because every state satisfies $\TRUE$.  Similarly, we have that $\satisfaction{\forall \nxt (\TRUE \vee \FALSE)}(s) = \top$.  To capture all these cases, we use the notion of equivalence of CTL formulas, denoted $\equiv$ (see \cite[Definition~6.12]{BK08}).  If $\varphi \equiv \TRUE$ then $\satisfaction{\forall \nxt \varphi}(s) = \top$.

Next, let us consider the case that $\varphi$ is $\FALSE$.  No state satisfies $\FALSE$.  Hence, $\satisfaction{\forall \nxt \FALSE}(s) = \perp$.  More generally, $\varphi \equiv \FALSE$ then $\satisfaction{\forall \nxt \varphi}(s) = \perp$.

Otherwise, $\varphi \not\equiv \TRUE$ and $\varphi \not\equiv \FALSE$.  The former implies that there exists a transition system with initial state $s_{\TRUE}$ such that $s_{\TRUE} \not\models \varphi$ and the latter implies that there exists a transition system with initial state $s_{\FALSE}$ such that $s_{\FALSE} \models \varphi$.  State~$s_0$ has at least one outgoing transition.  We do not know anything about the target state of that transition (it could be $s_{\TRUE}$ or $s_{\FALSE}$ or any other state), we do not know that value of $\satisfaction{\forall \nxt \varphi}(s)$.

Combining the above, we arrive at
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has a single explored outgoing transition to state~$s_1$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous case, if  $\varphi \equiv \TRUE$ then $\satisfaction{\forall \nxt \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\forall \nxt \varphi}(s) = \perp$.

Now let us consider state $s_1$ and formula $\varphi$.  If $\satisfaction{\varphi}(s_1) = \perp$, we can conclude that $\satisfaction{\forall \nxt \varphi}(s) = \perp$.  In case $\satisfaction{\varphi}(s) \not= \perp$, we obtain no additional information about $\satisfaction{\forall \nxt \varphi}(s)$.

Combining the above, we arrive at
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s_1) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
Note that $\satisfaction{\varphi}(s_1) = \perp$ if $\varphi \equiv \FALSE$.  Hence, we can simplify the above to
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s_1) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has explored outgoing transitions to state~$s_1$ and $s_2$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous cases, if  $\varphi \equiv \TRUE$ then $\satisfaction{\forall \nxt \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\forall \nxt \varphi}(s) = \perp$. 

Now let us consider state~$s_1$ and $s_2$.  If $\satisfaction{\varphi}(s_1) = \perp$ or $\satisfaction{\varphi}(s_2) = \perp$, we can conclude that $\satisfaction{\forall \nxt \varphi}(s) = \perp$.  In case $\satisfaction{\varphi}(s_1)\not= \perp$ and $\satisfaction{\varphi}(s_2)\not= \perp$, we obtain no additional information about $\satisfaction{\forall \nxt \varphi}(s)$.  Therefore,
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s_1) = \perp$ or $\satisfaction{\varphi}(s_2) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
This can be simplified to
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s_1) = \perp$ or $\satisfaction{\varphi}(s_2) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\end{itemize}
The above three cases can be generalized as follows.
\[
\satisfaction{\forall \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s') = \perp$ for some $s \rightarrow s'$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

This can be reformulated as follows.
\begin{align*}
\mathit{Sat}(\forall \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S & \mbox{if $\varphi \equiv \TRUE$}\\
\{\, s \in F \mid \mathit{post}(s) \subseteq \mathit{Sat}(\varphi) \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unsat}(\forall \nxt \varphi) & = 
\left \{
\begin{array}{ll}
(S \setminus F) \cup \{\, s \in F \mid \mathit{post}(s) \not= \emptyset \,\}& \mbox{if $\varphi \equiv \FALSE$}\\
\{\, s \in S \mid \mathit{post}(s) \cap \mathit{Unsat}(\varphi) \not= \emptyset \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unknown}(\forall \nxt \varphi) & = S \setminus (\mathit{Sat}(\forall \nxt \varphi) \cup \mathit{Unsat}(\forall \nxt \varphi))
\end{align*}
In the above characterization we use
\[
\mathit{post}(s) = \{\, s' \in S \mid s \rightarrow s' \,\}.
\]

Next, let us consider the formula $\exists \nxt \varphi$, where $\varphi$ is some arbitary formula.  Assume that the state~$s$ is fully explored.  In that case,
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s') = \top$ for some $s \rightarrow s'$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s') = \perp$ for all $s \rightarrow s'$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
The above is equivalent to
\[
\satisfaction{\exists \nxt \varphi}(s) = \bigvee \{\, \satisfaction{\varphi}(s') \mid s \rightarrow s' \,\}.
\]
Note that $\bigvee \emptyset = \perp$.

Next, assume that the state~$s$ is not fully explored.  Recall that state~$s$ has outgoing transitions, but those have not been explored yet.  We distinguish three cases.
\begin{itemize}
\item 
None of outgoing transitions of state~$s$ have been explored yet.  Let us first consider the case that $\varphi$ is $\TRUE$.  In that case, $\satisfaction{\exists \nxt \TRUE}(s) = \top$ because state~$s$ has outgoing transitions and every state satisfies $\TRUE$.  More generally, if $\varphi \equiv \TRUE$ then $\satisfaction{\exists \nxt \varphi}(s) = \top$.

Next, let us consider the case that $\varphi$ is $\FALSE$.  No state satisfies $\FALSE$.  Hence, $\satisfaction{\exists \nxt \FALSE}(s) = \perp$.  More generally, $\varphi \equiv \FALSE$ then $\satisfaction{\exists \nxt \varphi}(s) = \perp$.

Otherwise, $\varphi \not\equiv \TRUE$ and $\varphi \not\equiv \FALSE$.  The former implies that there exists a transition system with initial state $s_{\TRUE}$ such that $s_{\TRUE} \not\models \varphi$ and the latter implies that there exists a transition system with initial state $s_{\FALSE}$ such that $s_{\FALSE} \models \varphi$.  State~$s$ has at least one outgoing transition.  We do not know anything about the target state of that transition (it could be $s_{\TRUE}$ or $s_{\FALSE}$ or any other state), we do not know that value of $\satisfaction{\exists \nxt \varphi}(s)$.

Combining the above, we arrive at
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has a single explored outgoing transition to state~$s_1$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous case, if  $\varphi \equiv \TRUE$ then $\satisfaction{\exists \nxt \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\exists \nxt \varphi}(s) = \perp$.

Now let us consider state $s_1$ and formula $\varphi$.  If $\satisfaction{\varphi}(s_1) = \top$, we can conclude that $\satisfaction{\exists \nxt \varphi}(s) = \top$.  In case $\satisfaction{\varphi}(s_1)\not= \top$, we obtain no additional information about $\satisfaction{\exists \nxt \varphi}(s)$.

Combining the above, we arrive at
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$ or $\satisfaction{\varphi}(s_1) = \top$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
Note that $\satisfaction{\varphi}(s_1) = \top$ if $\varphi \equiv \TRUE$.  Hence, we can simplify the above to
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s_1) = \top$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has explored outgoing transitions to state~$s_1$ and $s_2$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous cases, if  $\varphi \equiv \TRUE$ then $\satisfaction{\exists \nxt \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\exists \nxt \varphi}(s) = \perp$. 

Now let us consider state~$s_1$ and $s_2$.  If $\satisfaction{\varphi}(s_1) = \top$ or $\satisfaction{\varphi}(s_2) = \top$, we can conclude that $\satisfaction{\exists \nxt \varphi}(s) = \top$.  In case $\satisfaction{\varphi}(s_1)\not= \top$ and $\satisfaction{\varphi}(s_2)\not= \top$, we obtain no additional information about $\satisfaction{\exists \nxt \varphi}(s)$.  Therefore,
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$ or $\satisfaction{\varphi}(s_1) = \top$ or $\satisfaction{\varphi}(s_2) = \top$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
This can be simplified to
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s_1) = \top$ or $\satisfaction{\varphi}(s_2) = \top$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\end{itemize}
The above three cases can be generalized as follows.
\[
\satisfaction{\exists \nxt \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$ or $\satisfaction{\varphi}(s') = \top$ for some $s \rightarrow s'$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

This can be reformulated as follows.
\begin{align*}
\mathit{Sat}(\exists \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S \setminus F \cup \{\, s \in F \mid \mathit{post}(s) \not= \emptyset \,\} & \mbox{if $\varphi \equiv \TRUE$}\\
\{\, s \in S \mid \mathit{post}(s) \cap \mathit{Sat}(\varphi) \not= \emptyset \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unsat}(\exists \nxt \varphi) & = 
\left \{
\begin{array}{ll}
S & \mbox{if $\varphi \equiv \FALSE$}\\
\{\, s \in F \mid \mathit{post}(s) \subseteq \mathit{Unsat}(\varphi) \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unknown}(\exists \nxt \varphi) & = S \setminus (\mathit{Sat}(\exists \nxt \varphi) \cup \mathit{Unsat}(\exists \nxt \varphi))
\end{align*}

Next, let us consider the formulas $\forall \always \varphi$.  Assume that the state $s$ is fully explored.  Then 
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s) = \top$ and $\satisfaction{\forall \always \varphi}(s') = \top$ for all $s \rightarrow s'$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s') = \perp$ for some $s \rightarrow s'$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

Next, assume that the state $s$ is not fully explored.  Recall that state~$s$ has outgoing transitions, but those have not been explored yet.  We distinguish three cases.
\begin{itemize}
\item 
None of outgoing transitions of state~$s$ have been explored yet.  Let us first consider the case that $\varphi$ is $\TRUE$.  In that case, $\satisfaction{\forall \always \TRUE}(s) = \top$ because each (reachable) state satisfies $\TRUE$.

Next, let us consider the case that $\varphi$ is $\FALSE$.  No state satisfies $\FALSE$.  Hence, $\satisfaction{\forall \always \FALSE}(s) = \perp$.  More generally, $\varphi \equiv \FALSE$ then $\satisfaction{\forall \always \varphi}(s) = \perp$.

If $\satisfaction{\varphi}(s) = \perp$, there exists a state reachable from state~$s$ that does not satisfy $\varphi$ and, hence, $\satisfaction{\forall \always \varphi}(s) = \perp$.

Otherwise, $\varphi \not\equiv \TRUE$ and $\varphi \not\equiv \FALSE$.  The former implies that there exists a transition system with initial state $s_{\TRUE}$ such that $s_{\TRUE} \not\models \varphi$ and the latter implies that there exists a transition system with initial state $s_{\FALSE}$ such that $s_{\FALSE} \models \varphi$.  Hence, $\satisfaction{\forall \always \varphi}(s) = ?$.

Combining the above, we arrive at
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
This can be further simplified to
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has a single explored outgoing transition to state~$s_1$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous case, if  $\varphi \equiv \TRUE$ then $\satisfaction{\forall \always \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\forall \always \varphi}(s) = \perp$.

If $\satisfaction{\varphi}(s) = \perp$, there exists a state reachable from state~$s$ that does not satisfy $\varphi$ and, hence, $\satisfaction{\forall \always \varphi}(s) = \perp$.

Now let us consider state $s_1$.  If $\satisfaction{\forall \always \varphi}(s_1) = \perp$, we can conclude that $\satisfaction{\forall \always \varphi}(s) = \perp$.  In case $\satisfaction{\forall \always \varphi}(s_1)\not= \perp$, we obtain no additional information about $\satisfaction{\forall \always \varphi}(s)$.

Combining the above, we arrive at
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s_1) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
This can be further simplified to
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s_1) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\item
State~$s$ has explored outgoing transitions to state~$s_1$ and $s_2$.  State~$s$ has more outgoing transitions, but those have not been explored yet.   As in the previous cases, if  $\varphi \equiv \TRUE$ then $\satisfaction{\forall \always \varphi}(s) = \top$, and if $\varphi \equiv \FALSE$ then $\satisfaction{\forall \always \varphi}(s) = \perp$. 

If $\satisfaction{\varphi}(s) = \perp$, there exists a state reachable from state~$s$ that does not satisfy $\varphi$ and, hence, $\satisfaction{\forall \always \varphi}(s) = \perp$.

Now let us consider state~$s_1$ and $s_2$.  If $\satisfaction{\forall \always \varphi}(s_1) = \perp$, we can conclude that $\satisfaction{\forall \always \varphi}(s) = \perp$.  Similarly, if $\satisfaction{\forall \always \varphi}(s_2) = \perp$, then $\satisfaction{\forall \always \varphi}(s) = \perp$.  Otherwise, we obtain no additional information about $\satisfaction{\forall \always \varphi}(s)$.  Therefore,
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\varphi \equiv \FALSE$ or $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s_1) = \perp$ or $\satisfaction{\forall \always \varphi}(s_2) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
This can be further simplified to
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s_1) = \perp$ or $\satisfaction{\forall \always \varphi}(s_2) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]
\end{itemize}
The above three cases can be generalized as follows.
\[
\satisfaction{\forall \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$ or $\satisfaction{\forall \always \varphi}(s') = \perp$ for some $s \rightarrow s'$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

Now consider that case that state~$s$ is not fully explored and transitions to itself and assume that $\varphi \not\equiv \FALSE$ and $\satisfaction{\varphi}(s) \not= \perp$.  Then $\satisfaction{\forall \always \varphi}(s) = \perp$ if $\satisfaction{\forall \always \varphi}(s) = \perp$.  To demonstrate that $\satisfaction{\forall \always \varphi}$ can be defined so that it satisfies the above equation, we will rely on the Knaster-Tarski fixed-point theorem \cite{K28,T55}.

Let us first reformulate the above in terms of $\mathit{Sat}$, $\mathit{Unsat}$, and $\mathit{Unknown}$.  
\begin{align*}
\mathit{Sat}(\forall \always \varphi) & = 
\left \{
\begin{array}{ll}
S & \mbox{if $\varphi \equiv \TRUE$}\\
\{\, s \in F \mid s \in \mathit{Sat}(\varphi) \wedge \mathit{post}(s) \subseteq \mathit{Sat}(\forall \always \varphi) \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unsat}(\forall \always \varphi) & = 
\left \{
\begin{array}{ll}
(S \setminus F) \cup \{\, s \in F \mid \mathit{post}(s) \not= \emptyset \,\} & \mbox{if $\varphi \equiv \FALSE$}\\
\{\, s \in S \mid s \in \mathit{Unsat}(\varphi) \vee \mathit{post}(s) \cap \mathit{Unsat}(\forall \always \varphi) \not= \emptyset \,\} & \mbox{otherwise}
\end{array}
\right .\\
\mathit{Unknown}(\forall \always \varphi) & = S \setminus (\mathit{Sat}(\forall \always \varphi) \cup \mathit{Unsat}(\forall \always \varphi))
\end{align*}

To address the above observed circularity, we start with ordering sets of states, that is, the elements of $2^S$.  Clearly, we have that for all $U$, $V$, $W \in 2^S$,
\begin{itemize}
\item 
$U \subseteq U$,
\item
if $U \subseteq V$ and $V \subseteq U$ then $U = V$, and
\item
if $U \subseteq V$ and $V \subseteq W$ then $U \subseteq W$.
\end{itemize}

The set $2^S$ and the order $\subseteq$ form a complete lattice (see, for example, \cite[Section~6.1]{CGP99}).  Given a CTL formula~$\varphi$, with $\varphi \not\equiv \TRUE$, the function
\[
\mathcal{F}_{\varphi} : 2^S \to 2^S
\]
is defined by
\[
\mathcal{F}_{\varphi}(U) = \{\, s \in F \mid s \in \mathit{Sat}(\varphi) \wedge \mathit{post}(s) \subseteq U \,\}.
\]

Next, we show that the function $\mathcal{F}_{\varphi}$ is monotone, that is, for all $U$, $V \in 2^S$, if $U \subseteq V$ then $\mathcal{F}_{\varphi}(U) \subseteq \mathcal{F}_{\varphi}(V)$.  Let $U$, $V \in 2^S$ and assume that $U \subseteq V$.  Let $s \in \mathcal{F}_{\varphi}(U)$. To conclude that $\mathcal{F}_{\varphi}(U) \subseteq \mathcal{F}_{\varphi}(V)$, it remains to show that $s \in \mathcal{F}_{\varphi}(V)$.  Since $s \in \mathcal{F}_{\varphi}(U)$, we have that $s \in F$, $s \in \mathit{Sat}(\varphi)$, and $\mathit{post}(s) \subseteq U$.  Since $U \subseteq V$, we can conclude that $\mathit{post}(s) \subseteq V$.  Hence, $s \in \mathcal{F}_{\varphi}(V)$.

According to the Knaster-Tarski theorem, a monotone function on a complete lattice has a greatest fixed-point.  As we already observed above, the set $2^S $ with the order $\subseteq$ is a complete lattice.  Furthermore, we have shown that the function $\mathcal{F}_{\varphi}$ is monotone.  Hence, $\mathcal{F}_{\varphi}$ has a greatest fixed point.  A set $U \in 2^S$ is a fixed-point of $\mathcal{F}_{\varphi}$ if $\mathcal{F}_{\varphi}(U) = U$.  A set $U \in 2^S$ is a greatest fixed-point of $\mathcal{F}_{\varphi}$ if $U$ is a fixed-point of $\mathcal{F}_{\varphi}$ and for every fixed-point $V$ of $\mathcal{F}_{\varphi}$ we have that $V \subseteq U$.  We define $\mathit{Sat}(\forall \always \varphi)$ as the greatest fixed-point of $\mathcal{F}_{\varphi}$.

Since the set $2^S$ is finite, the Knaster-Tarski fixed point theorem also suggests an algorithm to compute the greatest fixed-point of $\mathcal{F}_{\varphi}$ since this greatest fixed point is equal to
\[
\bigcup \{\, U \in 2^S \mid U \subseteq \mathcal{F}_{\varphi}(U) \,\}.
\]
According to, for example, \cite[Section~6.2]{CGP99}, we can compute $\mathit{Sat}(\forall \always \varphi)$ as follows.
\begin{lstlisting}
$U = S$
repeat
  $U_{old} = U$
  $U = \{\, s \in F \mid s \in \mathit{Sat}(\varphi) \wedge \mathit{post}(s) \subseteq U \,\}$
until $U_{old} = U$
\end{lstlisting}

\color{red}
Given a CTL formula~$\varphi$, with $\varphi \not\equiv \FALSE$, the function
\[
\mathcal{G}_{\varphi} : 2^S \to 2^S
\]
is defined by
\[
\mathcal{G}_{\varphi}(U) = \{\, s \in S \mid s \in \mathit{Unsat}(\varphi) \wedge \mathit{post}(s) \cap U \not= \emptyset \,\}.
\]

Next, we show that the function $\mathcal{G}_{\varphi}$ is monotone, that is, for all $U$, $V \in 2^S$, if $U \subseteq V$ then $\mathcal{G}_{\varphi}(U) \subseteq \mathcal{G}_{\varphi}(V)$.  Let $U$, $V \in 2^S$ and assume that $U \subseteq V$.  Let $s \in \mathcal{G}_{\varphi}(U)$. To conclude that $\mathcal{G}_{\varphi}(U) \subseteq \mathcal{G}_{\varphi}(V)$, it remains to show that $s \in \mathcal{G}_{\varphi}(V)$.  Since $s \in \mathcal{G}_{\varphi}(U)$, we have that $s \in S$, $s \in \mathit{Unsat}(\varphi)$ and $\mathit{post}(s) \cap U \not= \emptyset$.  Since $U \subseteq V$, we can conclude that $\mathit{post}(s) \cap V \not= \emptyset$.  Hence, $s \in \mathcal{G}_{\varphi}(V)$.

According to the Knaster-Tarski theorem, a monotone function on a complete lattice has a least fixed-point.  Since the set $2^S$ is finite, the Knaster-Tarski fixed point theorem also suggests an algorithm to compute the least fixed-point of $\mathcal{G}_{\varphi}$ since this least fixed point is equal to
\[
\bigcap \{\, U \in 2^S \mid \mathcal{G}_{\varphi}(U) \subseteq U \,\}.
\]
According to, for example, \cite[Section~6.2]{CGP99}, we can compute $\mathit{Unsat}(\forall \always \varphi)$ as follows.
\begin{lstlisting}
$U = \emptyset$
repeat
  $U_{old} = U$
  $U = \{\, s \in S \mid s \in \mathit{Unsat}(\varphi) \wedge \mathit{post}(s) \cap U \not= \emptyset \,\}$
until $U_{old} = U$
\end{lstlisting}

Next, let us consider the formulas $\exists \always \varphi$.  Assume that the state $s$ is fully explored.  Then 
\[
\satisfaction{\exists \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\satisfaction{\varphi}(s) = \top$ and ($s \not\rightarrow$ or $\satisfaction{\exists \always \varphi}(s') = \top$ for some $s \rightarrow s'$)}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$ or ($s \rightarrow$ and $\satisfaction{\exists \always \varphi}(s') = \perp$ for all $s \rightarrow s'$)}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

Next, assume that the state $s$ is not fully explored.  Then
\[
\satisfaction{\exists \always \varphi}(s) = \left \{
\begin{array}{ll}
\top & \mbox{if $\varphi \equiv \TRUE$ or ($\satisfaction{\varphi}(s) = \top$ and $\satisfaction{\exists \always \varphi}(s') = \top$ for some $s \rightarrow s'$)}\\
\perp & \mbox{if $\satisfaction{\varphi}(s) = \perp$}\\
? & \mbox{otherwise.}
\end{array}
\right .
\]

Let us first reformulate the above in terms of $\mathit{Sat}$, $\mathit{Unsat}$, and $\mathit{Unknown}$.  
\begin{align*}
\mathit{Sat}(\exists \always \varphi) = & 
\{\, s \in S \mid s \in \mathit{Sat}(\varphi) \wedge \mathit{post}(s) \cap \mathit{Sat}(\exists \always \varphi) \not= \emptyset \,\} \cup\\
& \{\, s \in F \mid s \in \mathit{Sat}(\varphi) \wedge \mathit{post}(s) = \emptyset \,\}\\
\mathit{Unsat}(\exists \always \varphi) = & 
\mathit{Unsat}(\varphi) \cup \{\, s \in F \mid \emptyset \not= \mathit{post}(s) \subseteq \mathit{Unsat}(\varphi) \,\}\\
\mathit{Unknown}(\exists \always \varphi) = & S \setminus (\mathit{Sat}(\exists \always \varphi) \cup \mathit{Unsat}(\exists \always \varphi))
\end{align*}

The set $\mathit{Sat}(\exists \always \varphi)$ can be defined as a greatest fixed-point.  
%The set $\mathit{Unsat}(\exists \always \varphi)$ can be defined as a ??? fixed-point.

\color{black}

\textcolor{blue}{Similarly, we might be able to characterize $\mathit{Unsat}(\forall \always \varphi)$ as a least fixed-point.}

\section{JPF Listener that Writes a Partial Transition System to File}

A listener for Java PathFinder (JPF) writes its partial transition system to file.  In \cite[Section~7.3]{B20}, a listener that writes a transition system to file has been developed.  This listener is extended to the setting of partial transition systems.

Consider the following partial transition system.
\begin{center}
\begin{tikzpicture}[yscale=0.9]
\node (start) at (0,3) {};
\node[rectangle,fill=red!20] (-1) at (1,2.5) {-1};
\node[rectangle,fill=red!20] (0) at (1,1) {0};
\node[circle,fill=red!20] (1) at (0,0) {1};
\node[circle,fill=red!20] (2) at (2,0) {2};

\draw[->] (start)--(-1);
\draw[->] (-1)--(0);
\draw[->] (0)--(1);
\draw[->] (0)--(2);
\end{tikzpicture}
\end{center}
State~-1 is the initial state.  The states -1 and 0 are fully explored, and  states 1 and 2 are not fully explored.  The listener produces a file, the name of which is the name of the system under test with ``.tra'' as suffix (see \cite[Section 7.4]{B20}), with the following content.
\begin{verbatim}
-1 -> 0
0 -> 1
0 -> 2
1 2
\end{verbatim}
The first three lines describe the transitions.  Each line contains the source of the transition followed by the target of the transition.  The last line contains the states that are not fully explored yet.

\bibliographystyle{plain}
\bibliography{report}

\end{document}

%
%\section{Normal forms for CTL}
%
%\description
%The objective of this project is to develop a translation of CTL formulas to equivalent formulas in existential normal form and positive normal form for partial transition systems (as defined in the ``new semantics for CTL'' project).  Existential normal form is introduced in Definition~6.13 of the textbook and positive normal form is defined in Definition~6.15.  These normal forms may have to be adjusted to deal with partial transition systems.  
%
%\resources
%\begin{itemize}
%\item 
%The textbook.
%\end{itemize}
%
%\deliverables
%\begin{itemize}
%\item
%Definitions of existential normal form and positive normal form for CTL for partial transition systems.
%\item
%A proof that for each CTL formula there exists an equivalent CTL formula in existential normal form in the context of partial transition systems (similar to the proof of Theorem~6.14 of the textbook, but considering partial transition systems and providing more details).  A similar result for positive normal form (see Theorem~6.16 of the textbook).
%\item
%A report containing the definitions, the proofs, and several examples illustrating how CTL formulas are translated into the normal forms.
%\end{itemize}
%
%\section{Translation of CTL to normal forms}
%
%\description
%The objective of this project is to implement the translation of CTL to both normal forms developed in the "normal forms for CTL" project. 
%
%Implement a class named \lstinline{ExistentialNormalForm} that contains a static method named \lstinline{translate}.  This method takes as argument an object of type \lstinline{Formula}, which is part of the \lstinline{ctl} package.  The API of the \lstinline{ctl} package can be found \href{https://www.eecs.yorku.ca/course_archive/2020-21/W/4315/project/api/ast}{here} and has been implemented in the ``from parse tree to abstract syntax tree'' project.  Similarly, develop a class named \lstinline{PositiveNormalForm} that contains a static method named \lstinline{translate}.
%
%To represent a CTL formula in the normal forms, you may use classes of the \lstinline{ctl} package.  You may also add new classes to this package.  A CTL formula can be translated to its existential normal form as follows.
%\begin{lstlisting}
%Formula formula = ...
%Formula normalForm = ExistentialNormalForm.translate(formula);
%\end{lstlisting}
%
%\deliverables
%\begin{itemize}
%\item
%Properly documented Java code that implements both translations of CTL to the normal forms.
%\item
%A test suite, using JUnit, that rigorously tests the translations.
%\item
%A report describing the design, implementation, and testing of the translations.
%\end{itemize}
%
%
%\section{CTL model checking algorithm for partial transition systems}
%
%\description
%The objective of this project is to adjust the CTL model checking algorithm, as described in Section~6.4.1 of the textbook, to the setting of partial transition systems, as developed in the ``new semantics for CTL'' project.  Given a partial transition system and a CTL formula in existential normal form, as developed in the `` existential normal form for CTL'' project, the algorithm computes the corresponding satisfaction set.
%
%\resources
%\begin{itemize}
%\item 
%The textbook.
%\end{itemize}
%
%\deliverables
%\begin{itemize}
%\item 
%An algorithm, similar to Algorithm~14 of the textbook, for the computation of the satisfaction sets of CTL formulas in existential normal form for a partial transition system.
%\item
%A proof that proves the algorithm is correct, similar to Theorem~6.23 of the textbook.
%\item
%A report describing the algorithm and its correctness proof.
%\end{itemize}
%
%\section{JPF listener that writes a partial transition system to file}
%
%\description
%The first objective of this project is to develop a listener for Java PathFinder (JPF) that writes its partial transition system to file.  Partial transition systems are defined in the ``new semantics for CTL'' project.  In Section~7.3 of the notes, a listener that writes a transition system to file has been developed.  This listener needs to be extended to the setting of partial transition systems.
%
%Consider the following partial transition system.
%\begin{center}
%\begin{tikzpicture}[yscale=0.9]
%\node (start) at (0,3) {};
%\node[rectangle,fill=red!20] (-1) at (1,2.5) {-1};
%\node[rectangle,fill=red!20] (0) at (1,1) {0};
%\node[circle,fill=red!20] (1) at (0,0) {1};
%\node[circle,fill=red!20] (2) at (2,0) {2};
%
%\draw[->] (start)--(-1);
%\draw[->] (-1)--(0);
%\draw[->] (0)--(1);
%\draw[->] (0)--(2);
%\end{tikzpicture}
%\end{center}
%State~-1 is the initial state.  The states -1 and 0 are fully explored, and  states 1 and 2 are not fully explored.  The listener should produce a file, the name of which is the name of the system under test with ``.tra'' as suffix (see Section 7.4 of the notes), with the following content.
%\begin{verbatim}
%-1 -> 0
%0 -> 1
%0 -> 2
%1 2
%\end{verbatim}
%The first three lines describe the transitions.  The last line contains the states that are not fully explored.
%
%The second objective of this project is to develop a listener for JPF that writes a graphical representation, using the DOT format, of a partial transition system to file.  In Section~7.4 of the notes, a similar listener is described.
%
%\resources
%\begin{itemize}
%\item 
%\href{https://wiki.eecs.yorku.ca/course_archive/2019-20/W/4315/_media/notes.pdf}{Java PathFinder: a tool to detect bugs in Java code}.
%\item
%\href{https://github.com/javapathfinder/jpf-core/wiki}{The Java PathFinder website}.
%\end{itemize}
%
%\deliverables
%\begin{itemize}
%\item 
%Properly documented Java code of the listeners.
%\item
%A test suite, ideally using JPF's extension of JUnit, that rigorously tests the listeners.
%\item
%A report describing the design, implementation, and testing of the listeners.
%\end{itemize}
%
%\section{Implementation of CTL model checking algorithm}
%
%\description
%The main objective of this project is to implement the algorithm developed in the ``CTL model checking algorithm for partial transition systems'' project.  As input, the algorithm takes a CTL formula in existential normal form, as implemented in the ``translation of CTL to existential normal form,'' and a partial transition system, provided by the `` JPF listener that writes a partial transition system to file.'' Another objective of this project is to design a simple GUI to import the file containing the partial transition system, to enter the CTL formula, and to run the implemented algorithm.
%
%\resources
%\begin{itemize}
%\item
%The textbook.
%\end{itemize}
%
%\deliverables
%\begin{itemize}
%\item 
%Properly documented Java code that implements the algorithm and the GUI.
%\item
%A test suite, using JUnit, that rigorously tests the implementation of the algorithm.
%\item
%A report describing the design, implementation, and testing of the algorithm.
%\end{itemize}
%
%\section{Dependencies between the projects}
%
%Several projects depend on other projects.  The diagram below depicts these dependencies.  If there is an arrow from one project to another, it means that the latter is dependent on the former.  As a consequence, the latter project needs (some of) the results of the former project.
%
%\begin{center}
%\begin{tikzpicture}
%\node (1) at (0,4) {1};
%\node (2) at (0,3) {2};
%\node (3) at (2,4) {3};
%\node (4) at (2,3) {4};
%\node (5) at (1,2) {5};
%\node (6) at (3,2) {6};
%\node (7) at (5,2) {7};
%\node (8) at (3,1) {8};
%
%\draw[->] (1)--(2);
%\draw[->] (2)--(5);
%\draw[->] (3)--(4);
%\draw[->] (4)--(5);
%\draw[->] (4)--(6);
%\draw[->] (5)--(8);
%\draw[->] (6)--(8);
%\draw[->] (7)--(8);
%\end{tikzpicture}
%\end{center}
%
%Because of these dependencies, deadlines of the projects differ.
%
%\begin{tabular}{rl}
%project number & deadline\\
%\hline
%1 & March 5\\
%2 & March 26\\
%3 & March 5\\
%4 & March 26\\
%5 & April 9\\
%6 & April 9\\
%7 & April 9\\
%8 & April 23 
%\end{tabular}
%
%\end{document}